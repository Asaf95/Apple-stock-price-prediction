# -*- coding: utf-8 -*-
"""LSTM

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P2ddgW3ry2ovIf7YUFsJgjeFc8Dh4Vnr

# Get Data
"""

from google.colab import files
from google.colab import drive
drive.mount('/content')

pip install alpha_vantage

from google.colab import drive
drive.mount('/content/drive')

import all

from google.colab import drive
drive.mount('/content/gdrive')
import sys    
path_to_module = '/content/drive/MyDrive/Data-Mi/Project_2/Code'
sys.path.append(path_to_module)
import asaf

def get_data():
  import pandas as pd
  from alpha_vantage.timeseries import TimeSeries
  import time

  """
  this module prepare the data for the ML models.
  function basic_prepare() -
      basic naming for the columns names and format the values to the right format (string/ int/ date)
      this function also calls the apply_stock_split and return to the main module the 
  function apply_stock_split() -
      normalize the values of the stock according to the current value of the stock share

  """

  def get_apple_stock_api():
      path_to_file = "****************"
      with open(path_to_file) as f:
          contents = f.read()
          print('a  a')
      return contents


  def get_apple_stock_data():
      ts = TimeSeries(key=get_apple_stock_api(), output_format='pandas')
      data, meta_data = ts.get_daily(symbol='AAPL', outputsize = 'full')
      data.to_csv('DATA/rawdata_AAPL.csv')

"""# data_preparation"""

def data_preparation():
  import matplotlib.pyplot as plt
  import pandas as pd

  """
  this module prepare the data for the ML models.
  function basic_prepare() -
      basic naming for the columns names and format the values to the right format (string/ int/ date)
      this function also calls the apply_stock_split and return to the main module the 
  function apply_stock_split() -
      normalize the values of the stock according to the current value of the stock share



  """


  def apply_stock_split(df, number, date):

      list_of_columns = ['high', 'low', 'close', 'open']
      for item in list_of_columns:
          df['temp'] = df[(df['date'] < date)][item].div(number)
          df['temp2'] = df['temp'].fillna(df[item])
          df[item] = df['temp2']
      df['temp'] = df[(df['date'] < date)]['volume'].div(1 / number)
      df['temp2'] = df['temp'].fillna(df['volume'])
      df['volume'] = df['temp2']
      return df


  def basic_prepare(df):
      """

      :param df:
      :return:
      """
      df = df.rename(columns={'1. open': 'open', '2. high': 'high', '3. low': 'low',
                              '4. close': 'close', '5. volume': 'volume'})
      df_org = df.copy()

      df_org['date'] = df_org.apply(lambda x: pd.to_datetime(x['date'], format='%Y-%m-%d'), axis=1)

      # """
      # handle the stock splits problem
      # """
      # thisdict = {
      #     "2020-08-31": 4,
      #     "2014-06-9": 7,
      #     "2005-02-28": 2,
      #     "2000-06-21": 2,
      #     "1987-06-16": 2
      # }
      # for key, value in thisdict.items():
      #     df_org = apply_stock_split1(df,value, key)
      #
      # df_org =df_org.drop(columns=['temp', 'temp2'])
      # asaf_data = df_org.copy()
      df_org.index = df_org.pop('date')
      plt.plot(df_org.index, df_org['open'])
      plt.show()

      return df

"""# models

## Getting the clean data
"""

import pandas as pd
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

df = pd.read_csv("/content/drive/MyDrive/Data-Mi/Project_2/DATA/AAPL.csv")
#df = pd.read_csv(data, encoding = "ISO-8859-1")
df = pd.DataFrame(df)
df_newL = df.copy()
df

from datetime import datetime
df['date'] = df.apply(lambda x: pd.to_datetime(x['Date'], format = '%Y-%m-%d') ,axis=1)

def apply_stock_split1(number, date):
  list_of_columns = ['high', 'low','close','open']
  list_of_columns1 = ['volume']
  for item in list_of_columns:
    df['temp'] = df[(df['date'] < date)][item].div(number)
    df['temp2'] = df['temp'].fillna(df[item])
    df[item] = df['temp2']
    
  df['temp'] = df[(df['date'] < date)]['volume'].div(1/number)
  df['temp2'] = df['temp'].fillna(df['volume'])
  df['volume'] = df['temp2']
      # Add a temp value to store tha colounm values temperery.
      #only if the new value is not NaN replace it with the real value for that row
thisdict = {
  "2020-08-31": 4,
  "2014-06-9": 7,
  "2005-02-28": 2,
  "2000-06-21":2,
  "1987-06-16":2
}
df

"""
for key, value in thisdict.items():
  print(key, ' and ', value)
  #apply_stock_split1(key, value)
    #apply_stock_split1(4,"2020-09-02")
"""

df_analysis = df.copy()
df

df_1999_2009 = df_analysis[(df_analysis['date'] <  "2009-01-1")].copy()
df_2009_2022 = df_analysis[(df_analysis['date'] >  "2009-01-1")].copy()
df

"""##Data Analysis

By the graph, we see that between the years 2008-2009 the stock value has down.
"""

df



import matplotlib.pyplot as plt
df.pop('date')
#df.index.pop('date')
#plt.plot(df.index, df['close'])

list_of_columns_analysis = ["Open",	"High",	"Low",	"Close",	"Volume"]

for item in list_of_columns_analysis:
  plt.plot(df.index, df[item])
  plt.legend(item)
  plt.show()

"""import matplotlib.pyplot as plt
df.index = df.pop('date')
plt.plot(df.index, df['close'])

plt.plot(df.index, df['high'])
plt.plot(df.index,  df['low'])
plt.legend(['high', 'low'])

## date are later then 2009
"""

import matplotlib.pyplot as plt
df_1999_2009.index = df_1999_2009.pop('date')
#plt.plot(df_1999_2009.index, df_1999_2009['close'])

import matplotlib.pyplot as plt
df_2009_2022.index = df_2009_2022.pop('Date')
plt.plot(df_2009_2022.index, df_2009_2022['Close'])

list_of_columns_analysis = ["Open",	"High",	"Low",	"Close",	"Volume"]

for item in list_of_columns_analysis:
  plt.plot(df_2009_2022.index, df_2009_2022[item])
  plt.legend(item)
  plt.show()

plt.plot(df_2009_2022.index, df_2009_2022['High'])
plt.plot(df_2009_2022.index,  df_2009_2022['Low'])
plt.legend(['High', 'Low'])

plt.plot(df.index, df['Close'])

import datetime

def str_to_datetime(s):
  split = s.split('-')
  year, month, day = int(split[0]), int(split[1]), int(split[2])
  return datetime.datetime(year=year, month=month, day=day)

datetime_object = str_to_datetime('1986-03-19')
datetime_object

import matplotlib.pyplot as plt

plt.plot(df.index, df['Close'])

"""# New LSTM"""

def New_LSTM():
  df_newL = df
  df_newL = df_newL[['Date', 'Close']]
  df_newL['Date']
  import datetime

  def str_to_datetime(s):
    split = s.split('-')
    year, month, day = int(split[0]), int(split[1]), int(split[2])
    return datetime.datetime(year=year, month=month, day=day)

  datetime_object = str_to_datetime('1986-03-19')
  datetime_object
  df_newL['Date'] = df_newL['Date'].apply(str_to_datetime)
  df_newL['Date']
  df_newL.index = df_newL.pop('Date')
  df_newL

  import matplotlib.pyplot as plt

  plt.plot(df_newL.index, df_newL['Close'])
  import numpy as np

  def df_to_windowed_df(dataframe, first_date_str, last_date_str, n=3):
    first_date = str_to_datetime(first_date_str)
    last_date  = str_to_datetime(last_date_str)

    target_date = first_date
    
    dates = []
    X, Y = [], []

    last_time = False
    while True:
      df_subset = dataframe.loc[:target_date].tail(n+1)
      
      if len(df_subset) != n+1:
        print(f'Error: Window of size {n} is too large for date {target_date}')
        return

      values = df_subset['Close'].to_numpy()
      x, y = values[:-1], values[-1]

      dates.append(target_date)
      X.append(x)
      Y.append(y)

      next_week = dataframe.loc[target_date:target_date+datetime.timedelta(days=7)]
      next_datetime_str = str(next_week.head(2).tail(1).index.values[0])
      next_date_str = next_datetime_str.split('T')[0]
      year_month_day = next_date_str.split('-')
      year, month, day = year_month_day
      next_date = datetime.datetime(day=int(day), month=int(month), year=int(year))
      
      if last_time:
        break
      
      target_date = next_date

      if target_date == last_date:
        last_time = True
      
    ret_df = pd.DataFrame({})
    ret_df['Target Date'] = dates
    
    X = np.array(X)
    for i in range(0, n):
      X[:, i]
      ret_df[f'Target-{n-i}'] = X[:, i]
    
    ret_df['Target'] = Y

    return ret_df

  # Start day second time around: '2021-03-25'
  windowed_df = df_to_windowed_df(df_newL, 
                                  '2021-03-25', 
                                  '2022-03-21', 
                                  n=3)
  print(windowed_df)

  def windowed_df_to_date_X_y(windowed_dataframe):
    df_as_np = windowed_dataframe.to_numpy()

    dates = df_as_np[:, 0]

    middle_matrix = df_as_np[:, 1:-1]
    X = middle_matrix.reshape((len(dates), middle_matrix.shape[1], 1))

    Y = df_as_np[:, -1]
    return dates, X.astype(np.float32), Y.astype(np.float32)

  dates, X, y = windowed_df_to_date_X_y(windowed_df)

  dates.shape, X.shape, y.shape

  q_80 = int(len(dates) * .8)
  q_90 = int(len(dates) * .9)

  dates_train, X_train, y_train = dates[:q_80], X[:q_80], y[:q_80]

  dates_val, X_val, y_val = dates[q_80:q_90], X[q_80:q_90], y[q_80:q_90]
  dates_test, X_test, y_test = dates[q_90:], X[q_90:], y[q_90:]

  plt.plot(dates_train, y_train)
  plt.plot(dates_val, y_val)
  plt.plot(dates_test, y_test)

  plt.legend(['Train', 'Validation', 'Test'])
  from tensorflow.keras.models import Sequential
  from tensorflow.keras.optimizers import Adam
  from tensorflow.keras import layers

  model = Sequential([layers.Input((3, 1)),
                      layers.LSTM(64),
                      layers.Dense(32, activation='relu'),
                      layers.Dense(32, activation='relu'),
                      layers.Dense(1)])

  model.compile(loss='mse', 
                optimizer=Adam(learning_rate=0.001),
                metrics=['mean_absolute_error'])

  model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=100)
  train_predictions = model.predict(X_train).flatten()

  plt.plot(dates_train, train_predictions)
  plt.plot(dates_train, y_train)
  plt.legend(['Training Predictions', 'Training Observations'])

  val_predictions = model.predict(X_val).flatten()

  plt.plot(dates_val, val_predictions)
  plt.plot(dates_val, y_val)
  plt.legend(['Validation Predictions', 'Validation Observations'])

  test_predictions = model.predict(X_test).flatten()

  plt.plot(dates_test, test_predictions)
  plt.plot(dates_test, y_test)
  plt.legend(['Testing Predictions', 'Testing Observations'])
  plt.plot(dates_train, train_predictions)
  plt.plot(dates_train, y_train)
  plt.plot(dates_val, val_predictions)
  plt.plot(dates_val, y_val)
  plt.plot(dates_test, test_predictions)
  plt.plot(dates_test, y_test)
  plt.legend(['Training Predictions', 
              'Training Observations',
              'Validation Predictions', 
              'Validation Observations',
              'Testing Predictions', 
              'Testing Observations'])
  
  from copy import deepcopy

  recursive_predictions = []
  recursive_dates = np.concatenate([dates_val, dates_test])

  for target_date in recursive_dates:
    last_window = deepcopy(X_train[-1])
    next_prediction = model.predict(np.array([last_window])).flatten()
    recursive_predictions.append(next_prediction)
    last_window[-1] = next_prediction

  plt.plot(dates_train, train_predictions)
  plt.plot(dates_train, y_train)
  plt.plot(dates_val, val_predictions)
  plt.plot(dates_val, y_val)
  plt.plot(dates_test, test_predictions)
  plt.plot(dates_test, y_test)
  plt.plot(recursive_dates, recursive_predictions)
  plt.legend(['Training Predictions', 
              'Training Observations',
              'Validation Predictions', 
              'Validation Observations',
              'Testing Predictions', 
              'Testing Observations',
              'Recursive Predictions'])

df_newL = df_newL[['Date', 'Close']]
df_newL['Date']

import datetime

def str_to_datetime(s):
  split = s.split('-')
  year, month, day = int(split[0]), int(split[1]), int(split[2])
  return datetime.datetime(year=year, month=month, day=day)

datetime_object = str_to_datetime('1986-03-19')
datetime_object

df_newL

df_newL['Date'] = df_newL['Date'].apply(str_to_datetime)
df_newL['Date']

df_newL.index = df_newL.pop('Date')
df_newL

import matplotlib.pyplot as plt

plt.plot(df_newL.index, df_newL['Close'])

import numpy as np

def df_to_windowed_df(dataframe, first_date_str, last_date_str, n=3):
  first_date = str_to_datetime(first_date_str)
  last_date  = str_to_datetime(last_date_str)
  target_date = first_date
  dates = []
  X, Y = [], []
  last_time = False
  
  while True:
    df_subset = dataframe.loc[:target_date].tail(n+1)
    
    if len(df_subset) != n+1:
      print(f'Error: Window of size {n} is too large for date {target_date}')
      return

    values = df_subset['Close'].to_numpy()
    x, y = values[:-1], values[-1]

    dates.append(target_date)
    X.append(x)
    Y.append(y)

    next_week = dataframe.loc[target_date:target_date+datetime.timedelta(days=7)]
    next_datetime_str = str(next_week.head(2).tail(1).index.values[0])
    next_date_str = next_datetime_str.split('T')[0]
    year_month_day = next_date_str.split('-')
    year, month, day = year_month_day
    next_date = datetime.datetime(day=int(day), month=int(month), year=int(year))
    
    if last_time:
      break
    
    target_date = next_date

    if target_date == last_date:
      last_time = True
    
  ret_df = pd.DataFrame({})
  ret_df['Target Date'] = dates
  
  X = np.array(X)
  for i in range(0, n):
    X[:, i]
    ret_df[f'Target-{n-i}'] = X[:, i]
  
  ret_df['Target'] = Y

  return ret_df

# Start day second time around: '2021-03-25'
windowed_df = df_to_windowed_df(df_newL, 
                                '2021-03-25', 
                                '2022-03-21', 
                                n=3)
windowed_df

def windowed_df_to_date_X_y(windowed_dataframe):
  df_as_np = windowed_dataframe.to_numpy()

  dates = df_as_np[:, 0]

  middle_matrix = df_as_np[:, 1:-1]
  X = middle_matrix.reshape((len(dates), middle_matrix.shape[1], 1))

  Y = df_as_np[:, -1]

  return dates, X.astype(np.float32), Y.astype(np.float32)

dates, X, y = windowed_df_to_date_X_y(windowed_df)

dates.shape, X.shape, y.shape

q_80 = int(len(dates) * .8)
q_90 = int(len(dates) * .9)

dates_train, X_train, y_train = dates[:q_80], X[:q_80], y[:q_80]

dates_val, X_val, y_val = dates[q_80:q_90], X[q_80:q_90], y[q_80:q_90]
dates_test, X_test, y_test = dates[q_90:], X[q_90:], y[q_90:]

plt.plot(dates_train, y_train)
plt.plot(dates_val, y_val)
plt.plot(dates_test, y_test)

plt.legend(['Train', 'Validation', 'Test'])

from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import Adam
from tensorflow.keras import layers

model = Sequential([layers.Input((3, 1)),
                    layers.LSTM(64),
                    layers.Dense(32, activation='relu'),
                    layers.Dense(32, activation='relu'),
                    layers.Dense(1)])

model.compile(loss='mse', 
              optimizer=Adam(learning_rate=0.001),
              metrics=['mean_absolute_error'])

model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=100)

train_predictions = model.predict(X_train).flatten()

plt.plot(dates_train, train_predictions)
plt.plot(dates_train, y_train)
plt.legend(['Training Predictions', 'Training Observations'])

val_predictions = model.predict(X_val).flatten()

plt.plot(dates_val, val_predictions)
plt.plot(dates_val, y_val)
plt.legend(['Validation Predictions', 'Validation Observations'])

test_predictions = model.predict(X_test).flatten()

plt.plot(dates_test, test_predictions)
plt.plot(dates_test, y_test)
plt.legend(['Testing Predictions', 'Testing Observations'])

plt.plot(dates_train, train_predictions)
plt.plot(dates_train, y_train)
plt.plot(dates_val, val_predictions)
plt.plot(dates_val, y_val)
plt.plot(dates_test, test_predictions)
plt.plot(dates_test, y_test)
plt.legend(['Training Predictions', 
            'Training Observations',
            'Validation Predictions', 
            'Validation Observations',
            'Testing Predictions', 
            'Testing Observations'])

from copy import deepcopy

recursive_predictions = []
recursive_dates = np.concatenate([dates_val, dates_test])

for target_date in recursive_dates:
  last_window = deepcopy(X_train[-1])
  next_prediction = model.predict(np.array([last_window])).flatten()
  recursive_predictions.append(next_prediction)
  last_window[-1] = next_prediction

plt.plot(dates_train, train_predictions)
plt.plot(dates_train, y_train)
plt.plot(dates_val, val_predictions)
plt.plot(dates_val, y_val)
plt.plot(dates_test, test_predictions)
plt.plot(dates_test, y_test)
plt.plot(recursive_dates, recursive_predictions)
plt.legend(['Training Predictions', 
            'Training Observations',
            'Validation Predictions', 
            'Validation Observations',
            'Testing Predictions', 
            'Testing Observations',
            'Recursive Predictions'])

"""# Main """

import pandas as pd

"""
the main module calls all the other modules and have access to all the functions that are needed 
for building the stock model
the main three modules are:
1. get_data()- using this module for getting the last stock price and the history prices.
2. data_preparation()- using this module to prepare the data for the ML models by fixing the types of columns 
fixing the stock splits issue and more.
3. model_lstm()- predict the stock value and is the main ML model in this project.
"""


def main():
  New_LSTM(df)
    #get_data.get_apple_stock_data()
    # raw_data = pd.read_csv('data/apple_daily_data')
    # prepare_data = data_preparation.basic_prepare(raw_data)
    # recursive_predictions = model_lstm.LSTM_prepare_variables(prepare_data)
    # print(recursive_predictions)
    #results = ml_classification_models.classification_models(prepare_data)
    #print(results)


if __name__ == "__main__":
  main()